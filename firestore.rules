/**
 * @fileoverview Firestore Security Rules for Prototyping.
 *
 * Core Philosophy:
 * This ruleset prioritizes security by strictly controlling data access based on user roles and ownership,
 * while adopting a flexible approach to data validation to facilitate rapid prototyping.
 * This means authorization is carefully enforced, but schema validation is relaxed.
 *
 * Data Structure:
 * - Users: Candidate, Employer, and Institute profiles are stored in separate top-level collections
 *   (`/candidates/{userId}`, `/employers/{userId}`, `/institutes/{userId}`).
 * - Job and Internship postings are stored in top-level collections (`/jobs/{jobId}`, `/internships/{internshipId}`).
 * - Applications are stored in a top-level collection (`/applications/{applicationId}`).
 *
 * Key Security Decisions:
 * - Strict ownership model for user profiles: Only the authenticated user can read/write their own profile.
 * - Public read access to job and internship postings, but restricted create/update/delete access to owners (employers).
 *   The 'employerId' field within jobs and internships is used to enforce ownership.
 * - Application documents can only be created with valid `candidateId` and `employerId`, and other relational
 *   fields.
 * - Listing of user profiles is disallowed for privacy.
 *
 * Denormalization for Authorization:
 * - Jobs and Internships: The `employerId` field is crucial for authorization. Without it, only completely
 *   public or completely private access would be possible.
 * - Applications: The `candidateId` and `employerId` fields are crucial for authorization and linking.
 *
 * Structural Segregation:
 * - User profiles are segregated into separate collections based on role (candidate, employer, institute). This
 *   simplifies access control and avoids the need for complex role-based queries.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Restricts access to candidate profiles to the owning user.
     * @path /candidates/{userId}
     * @allow (get, create, update, delete): Authenticated user with matching userId.
     * @deny (get, create, update, delete): Any other user.
     * @principle Enforces document ownership for writes.
     */
    match /candidates/{userId} {
      // Helper function to check if the user is signed in and owns the document.
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.email == request.auth.token.email;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Restricts access to employer profiles to the owning user.
     * @path /employers/{userId}
     * @allow (get, create, update, delete): Authenticated user with matching userId.
     * @deny (get, create, update, delete): Any other user.
     * @principle Enforces document ownership for writes.
     */
    match /employers/{userId} {
          // Helper function to check if the user is signed in and owns the document.
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Restricts access to institute profiles to the owning user.
     * @path /institutes/{userId}
     * @allow (get, create, update, delete): Authenticated user with matching userId.
     * @deny (get, create, update, delete): Any other user.
     * @principle Enforces document ownership for writes.
     */
    match /institutes/{userId} {
          // Helper function to check if the user is signed in and owns the document.
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to job postings, but restricts create/update/delete to the owning employer.
     * @path /jobs/{jobId}
     * @allow (get, list): Any user (including unauthenticated).
     * @allow (create): Authenticated employer creating a job with their employerId.
     * @allow (update, delete): Authenticated employer who owns the job posting.
     * @deny (create, update, delete): Any other user.
     * @principle Allows public read access with owner-only writes, enforcing ownership via the 'employerId' field.
     */
    match /jobs/{jobId} {
        // Helper function to check if the user is signed in and owns the document via employerId.
        function isOwner(employerId) {
          return request.auth != null && request.auth.uid == employerId;
        }
        function isExistingOwner(employerId) {
          return isOwner(employerId) && resource != null;
        }
      allow get: if true;
      allow list: if true;
      allow create: if request.auth != null && request.resource.data.employerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.employerId);
      allow delete: if isExistingOwner(resource.data.employerId);
    }

      /**
       * @description Allows public read access to internship postings, but restricts create/update/delete to the owning employer.
       * @path /internships/{internshipId}
       * @allow (get, list): Any user (including unauthenticated).
       * @allow (create): Authenticated employer creating a internship with their employerId.
       * @allow (update, delete): Authenticated employer who owns the internship posting.
       * @deny (create, update, delete): Any other user.
       * @principle Allows public read access with owner-only writes, enforcing ownership via the 'employerId' field.
       */
    match /internships/{internshipId} {
        // Helper function to check if the user is signed in and owns the document via employerId.
        function isOwner(employerId) {
          return request.auth != null && request.auth.uid == employerId;
        }
        function isExistingOwner(employerId) {
          return isOwner(employerId) && resource != null;
        }
      allow get: if true;
      allow list: if true;
      allow create: if request.auth != null && request.resource.data.employerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.employerId);
      allow delete: if isExistingOwner(resource.data.employerId);
    }

    /**
     * @description Restricts access to application documents, allowing creation by candidates and read access based on candidateId or employerId.
     * @path /applications/{applicationId}
     * @allow (create): Authenticated candidate creating an application with their candidateId.
     * @allow (get): Authenticated user who is either the candidate or the employer for the application.
     * @deny (list, update, delete): All users.
     * @principle Enforces that applications can only be created by candidates for themselves, and access is restricted to involved parties.
     */
    match /applications/{applicationId} {
      // Helper function to check if the user is the candidate or the employer for the application.
      function isParticipant(candidateId, employerId) {
        return request.auth != null && (request.auth.uid == candidateId || request.auth.uid == employerId);
      }

      allow get: if isParticipant(resource.data.candidateId, resource.data.employerId);
      allow list: if false;
      allow create: if request.auth != null && request.resource.data.candidateId == request.auth.uid;
      allow update: if false;
      allow delete: if false;
    }
  }
}