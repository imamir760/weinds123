/**
 * @fileoverview Firestore Security Rules for Prototyping.
 *
 * Core Philosophy:
 * This ruleset prioritizes security by enforcing strict user-ownership for
 * user profiles and employer ownership for jobs and internships. It allows
 * public read access to job and internship postings but restricts modifications
 * to the posting employer. This approach balances open access for discovery with
 * controlled authorization for data modification.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile information. Access is restricted to the owner.
 * - /jobs/{jobId}: Stores job postings. Publicly readable but only the employer can modify.
 * - /internships/{internshipId}: Stores internship postings. Publicly readable but only the employer can modify.
 *
 * Key Security Decisions:
 * - User profiles are strictly private and accessible only to the owning user.
 * - Listing of users is disallowed for privacy reasons.
 * - Jobs and Internships are publicly listable to enable discovery.
 * - Ownership of Jobs and Internships is determined by the `employerId` field in the document.
 *
 * Denormalization for Authorization:
 * The rules rely on the `employerId` field within the `jobs` and `internships` documents to
 * quickly verify ownership during write operations. This denormalization avoids costly and
 * complex queries during authorization checks.
 *
 * Structural Segregation:
 * User profiles are stored in a separate collection (`/users/{userId}`) from job and internship postings
 * (`/jobs/{jobId}`, `/internships/{internshipId}`), reflecting the different access control requirements
 * for these data types.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects user profiles, ensuring only the owner can read and write.
     * @path /users/{userId}
     * @allow (get, create, update, delete) User with matching {userId} in request.auth
     * @deny (get, create, update, delete) User with non-matching {userId} in request.auth
     * @principle Enforces document ownership for all operations on user profiles.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Listing users is not allowed.
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to job postings while restricting writes to the owner.
     * @path /jobs/{jobId}
     * @allow (get, list) Anyone can read job postings.
     * @allow (create) Employer with matching employerId in request.auth
     * @allow (update, delete) Employer with matching employerId in resource.data
     * @deny (create, update, delete) Non-employer attempting to create, update or delete job postings.
     * @principle Allows public read access with owner-only writes, validating ownership on create and update.
     */
    match /jobs/{jobId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.employerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.employerId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.employerId);
    }

    /**
     * @description Allows public read access to internship postings while restricting writes to the owner.
     * @path /internships/{internshipId}
     * @allow (get, list) Anyone can read internship postings.
     * @allow (create) Employer with matching employerId in request.auth
     * @allow (update, delete) Employer with matching employerId in resource.data
     * @deny (create, update, delete) Non-employer attempting to create, update, or delete internship postings.
     * @principle Allows public read access with owner-only writes, validating ownership on create and update.
     */
    match /internships/{internshipId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.employerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.employerId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.employerId);
    }

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(ownerId) {
      return isSignedIn() && request.auth.uid == ownerId && resource != null;
    }
  }
}