/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user profiles
 * (candidates, employers, institutes). It allows public read access to job and
 * internship postings, but restricts write access to the posting employer. Applications are secured such that only the involved candidate can create them,
 * and only the employer who owns the related post can access them.
 *
 * Data Structure:
 * - /candidates/{userId}: Candidate profiles, owned by the user.
 * - /employers/{userId}: Employer profiles, owned by the user.
 * - /institutes/{userId}: Institute profiles, owned by the user.
 * - /jobs/{jobId}: Job postings, publicly readable but employer-owned for writes, contains `employerId` field.
 * - /internships/{internshipId}: Internship postings, publicly readable but employer-owned for writes, contains `employerId` field.
 * - /applications/{applicationId}: Applications, accessible to the candidate and the owning employer.
 *
 * Key Security Decisions:
 * - User listing is disallowed for all user types.
 * - Public read access is granted to job and internship postings for discovery.
 * - Applications are secured such that only the candidate can create, and only the employer
 *   associated with the job can read.
 *
 * Denormalization for Authorization:
 * - The `Job` and `Internship` entities include an `employerId` field to simplify ownership checks.
 * - The `Application` entity includes both `candidateId` and `employerId` for authorization.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Only the authenticated user can read or write their own profile.
     * @path /candidates/{userId}
     * @allow (get, update, delete) User with matching {userId} can access their profile.
     * @allow (create) User can create their profile if {userId} matches their auth.uid.
     * @deny (get, update, delete) User cannot access another user's profile.
     * @deny (create) User cannot create a profile with a mismatched {userId}.
     * @principle Enforces document ownership for all operations.
     */
    match /candidates/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.email == request.auth.token.email;
      allow update: if isSignedIn() && isOwner(userId) && resource.data.email == request.auth.token.email;
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Only the authenticated user can read or write their own profile.
     * @path /employers/{userId}
     * @allow (get, update, delete) User with matching {userId} can access their profile.
     * @allow (create) User can create their profile if {userId} matches their auth.uid.
     * @deny (get, update, delete) User cannot access another user's profile.
     * @deny (create) User cannot create a profile with a mismatched {userId}.
     * @principle Enforces document ownership for all operations.
     */
    match /employers/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.email == request.auth.token.email;
      allow update: if isSignedIn() && isOwner(userId) && resource.data.email == request.auth.token.email;
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Only the authenticated user can read or write their own profile.
     * @path /institutes/{userId}
     * @allow (get, update, delete) User with matching {userId} can access their profile.
     * @allow (create) User can create their profile if {userId} matches their auth.uid.
     * @deny (get, update, delete) User cannot access another user's profile.
     * @deny (create) User cannot create a profile with a mismatched {userId}.
     * @principle Enforces document ownership for all operations.
     */
    match /institutes/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.tpoEmail == request.auth.token.email;
      allow update: if isSignedIn() && isOwner(userId) && resource.data.tpoEmail == request.auth.token.email;
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Allows public read access to job postings, but restricts write access to the posting employer.
     * @path /jobs/{jobId}
     * @allow (get, list) Anyone can read job postings.
     * @allow (create) Only the authenticated employer can create a job posting.
     * @allow (update, delete) Only the authenticated employer who created the job posting can update or delete it.
     * @deny (create) Non-employers cannot create job postings.
     * @deny (update, delete) Users who are not the job posting's employer cannot modify or delete it.
     * @principle Implements public read access with owner-only writes based on the `employerId` field.
     */
    match /jobs/{jobId} {
      function isOwner(employerId) {
        return request.auth.uid == employerId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      function isExistingOwner(employerId) {
        return isOwner(employerId) && resource != null;
      }
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && isOwner(request.resource.data.employerId);
      allow update: if isExistingOwner(resource.data.employerId);
      allow delete: if isExistingOwner(resource.data.employerId);
    }

    /**
     * @description Allows public read access to internship postings, but restricts write access to the posting employer.
     * @path /internships/{internshipId}
     * @allow (get, list) Anyone can read internship postings.
     * @allow (create) Only the authenticated employer can create a internship posting.
     * @allow (update, delete) Only the authenticated employer who created the internship posting can update or delete it.
     * @deny (create) Non-employers cannot create internship postings.
     * @deny (update, delete) Users who are not the internship posting's employer cannot modify or delete it.
     * @principle Implements public read access with owner-only writes based on the `employerId` field.
     */
    match /internships/{internshipId} {
      function isOwner(employerId) {
        return request.auth.uid == employerId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      function isExistingOwner(employerId) {
        return isOwner(employerId) && resource != null;
      }
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && isOwner(request.resource.data.employerId);
      allow update: if isExistingOwner(resource.data.employerId);
      allow delete: if isExistingOwner(resource.data.employerId);
    }

    /**
     * @description Allows candidate to create the application, and the job/internship posting employer to read applications
     * @path /applications/{applicationId}
     * @allow (create) Only the authenticated candidate can create an application.
     * @allow (get, list) Only the authenticated employer who owns the post can read applications.
     * @deny (create) Non-candidates cannot create applications.
     * @deny (get, list) Users who are not the job posting's employer or the applicant cannot read it.
     * @principle Implements owner-only read access for employers and create access for candidates.
     */
    match /applications/{applicationId} {
        function isCandidate(candidateId) {
            return request.auth.uid == candidateId;
        }
        function isEmployer(employerId) {
            return request.auth.uid == employerId;
        }
        function isSignedIn() {
          return request.auth != null;
        }
        allow get, list: if isSignedIn() && isEmployer(resource.data.employerId);
        allow create: if isSignedIn() && isCandidate(request.resource.data.candidateId);
        allow update, delete: if false;
    }
  }
}